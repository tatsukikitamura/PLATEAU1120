# PLATEAU-1120 コード最適化提案書

## 分析日: 2025年1月27日

PLATEAU-1120プロジェクトの全ファイルを探索し、最適化できる箇所を特定しました。

## 最適化の機会

### 1. **HTTPリクエストの重複コード（優先度: 高）**

#### 問題点
4つのサービスクラスで同じ`make_request`メソッドが重複して定義されています。

#### 対象ファイル
- `app/services/api/deepseek_chat_service.rb`
- `app/services/api/google_maps_determiner.rb`
- `app/services/api/map_display_determiner.rb`
- `app/services/api/google_maps_query_generator.rb`

#### 現状のコード例
各ファイルにほぼ同じ以下のコードが存在：

```ruby
def make_request(endpoint, params)
  uri = URI("#{BASE_URL}#{endpoint}")
  
  http = Net::HTTP.new(uri.host, uri.port)
  http.use_ssl = true
  http.open_timeout = 30
  http.read_timeout = 60
  
  request = Net::HTTP::Post.new(uri)
  request["Content-Type"] = "application/json"
  request["Authorization"] = "Bearer #{api_key}"
  request.body = params.to_json
  
  response = http.request(request)
  # ... レスポンス処理
end
```

#### 推奨される改善策

`app/services/api/concerns/deepseek_api_client.rb` を作成：

```ruby
module Api::Concerns::DeepseekApiClient
  extend ActiveSupport::Concern
  
  BASE_URL = "https://api.deepseek.com"
  MODEL = "deepseek-chat"
  
  included do
    attribute :api_key, default: -> { ENV["DEEPSEEK_API_KEY"] }
    
    validate :api_key_present
    
    def api_key_present
      if api_key.blank?
        raise ArgumentError, "DeepSeek API key is required"
      end
    end
  end
  
  private
  
  def make_request(endpoint, params)
    uri = URI("#{BASE_URL}#{endpoint}")
    
    if Rails.env.development?
      Rails.logger.info "=== #{self.class.name} API Request ==="
      Rails.logger.info "URL: #{uri}"
      Rails.logger.info "Params: #{params.inspect}"
      Rails.logger.info "=========================================="
    end
    
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = true
    http.open_timeout = 30
    http.read_timeout = 60
    
    request = Net::HTTP::Post.new(uri)
    request["Content-Type"] = "application/json"
    request["Authorization"] = "Bearer #{api_key}"
    request.body = params.to_json
    
    response = http.request(request)
    
    if Rails.env.development?
      Rails.logger.info "=== #{self.class.name} API Response ==="
      Rails.logger.info "Status Code: #{response.code}"
      Rails.logger.info "Response Body: #{response.body}"
      Rails.logger.info "==============================="
    end
    
    if response.code == "200"
      parsed_response = JSON.parse(response.body)
      parsed_response
    else
      Rails.logger.error "DeepSeek API error: #{response.code} - #{response.body}"
      nil
    end
  rescue => e
    Rails.logger.error "#{self.class.name} API request error: #{e.message}"
    Rails.logger.error "Error backtrace: #{e.backtrace.join("\n")}" if Rails.env.development?
    nil
  end
end
```

各サービスクラスで使用：

```ruby
class Api::DeepseekChatService
  include ActiveModel::Model
  include ActiveModel::Attributes
  include Api::Concerns::DeepseekApiClient
  
  def initialize(attributes = {})
    super
    # api_keyのバリデーションはConcernが実行
  end
  
  # make_requestメソッドの定義は不要
end
```

#### 効果
- コード重複の削減（約150行の削減）
- メンテナンス性の向上
- 一貫したエラーハンドリング
- API仕様変更時の影響範囲の最小化

---

### 2. **過剰なconsole.logの削減（優先度: 中）**

#### 問題点
JavaScriptファイル全体で96箇所の`console.log`が使用されています。

#### 詳細な分布
- `app/javascript/chatbot_map_application.js`: 9箇所
- `app/javascript/plateau/filters/schema.js`: 14箇所
- `app/javascript/plateau/ui/controller.js`: 14箇所
- `app/javascript/plateau/cesium/google_maps_loader.js`: 14箇所
- その他複数ファイル

#### 問題箇所の例
```javascript
// app/javascript/plateau/filters/schema.js
console.log("=== buildMultiSchemaPredicates 開始 ===");
console.log("入力criteria:", criteria);
console.log(`データ型[${dataType}]の変換後criteria:`, dataTypeCriteria);
console.log("=== buildMultiSchemaPredicates 完了 ===");

// app/javascript/plateau/filters/schema.js
const shouldLog = featureCount <= 2; // 最初の2件だけログ出力
if (shouldLog) {
  console.log(`--- フィーチャー ${featureCount} の判定開始 ---`);
  console.log("プロパティ:", p);
}
```

#### 推奨される改善策

`app/javascript/utils/logger.js` を作成：

```javascript
/**
 * 環境に応じたログ出力ユーティリティ
 */
const isDevelopment = typeof process !== 'undefined' && 
                      (process.env?.NODE_ENV === 'development' || 
                       !process.env?.NODE_ENV);

export const logger = {
  /**
   * 開発環境でのみログ出力
   */
  log: (...args) => {
    if (isDevelopment) {
      console.log(...args);
    }
  },
  
  /**
   * 警告ログ（開発環境でのみ出力）
   */
  warn: (...args) => {
    if (isDevelopment) {
      console.warn(...args);
    }
  },
  
  /**
   * エラーログ（常に出力）
   */
  error: (...args) => {
    console.error(...args);
  },
  
  /**
   * デバッグログ（詳細な情報、条件付き出力）
   */
  debug: (message, data) => {
    if (isDevelopment && localStorage.getItem('enableDebugLogs') === 'true') {
      console.log(`[DEBUG] ${message}`, data);
    }
  },
  
  /**
   * グループ化されたログ
   */
  group: (label, callback) => {
    if (isDevelopment) {
      console.group(label);
      try {
        callback();
      } finally {
        console.groupEnd();
      }
    }
  }
};

// グローバルアクセス用
if (typeof window !== 'undefined') {
  window.logger = logger;
}
```

使用例：

```javascript
// 変更前
console.log("=== buildMultiSchemaPredicates 開始 ===");
console.log("入力criteria:", criteria);

// 変更後
import { logger } from "utils/logger";

logger.group("buildMultiSchemaPredicates", () => {
  logger.debug("入力criteria", criteria);
  // ... 処理
});
```

#### 効果
- 本番環境でのログ出力削減によるパフォーマンス向上
- デバッグ時の詳細ログをコントロール可能
- エラーログのみ本番で出力され、保守性向上

---

### 3. **chatbot.js と chatbot_map_application.js の重複コード（優先度: 中）**

#### 問題点
チャット機能の実装が2つのファイルで重複しています。

#### 重複している機能
- メッセージの追加（`addMessage`関数 → 113行目）
- タイピングインジケーターの表示・削除（`showTypingIndicator`, `removeTypingIndicator` → 159-204行目）
- タイムスタンプの生成（`getTimestamp` → 207-212行目）
- スクロール制御（`scrollToBottom` → 215-217行目）
- データ選択メッセージの表示（`showDataSelectionMessage` → 220-257行目）

#### 推奨される改善策

共通機能を抽出したモジュールを作成：

`app/javascript/chatbot/core.js` を作成：

```javascript
/**
 * Chatbot共通機能
 */

export class ChatUI {
  constructor(elements) {
    this.chatMessages = elements.chatMessages;
    this.messageInput = elements.messageInput;
    this.sendBtn = elements.sendBtn;
    this.messageId = 0;
    this.chatHistory = [];
  }
  
  addMessage(text, isUser = false, isHtml = false) {
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${isUser ? 'user-message' : 'bot-message'}`;
    messageDiv.id = `message-${this.messageId++}`;
    
    const avatar = document.createElement('div');
    avatar.className = 'message-avatar';
    avatar.innerHTML = `<i class="fas ${isUser ? 'fa-user' : 'fa-robot'}"></i>`;
    
    const content = document.createElement('div');
    content.className = 'message-content';
    
    const header = document.createElement('div');
    header.className = 'message-header';
    header.innerHTML = `
      <strong>${isUser ? 'あなた' : 'AIアシスタント'}</strong>
      <span class="timestamp">${this.getTimestamp()}</span>
    `;
    
    const messageText = document.createElement('div');
    messageText.className = 'message-text';
    
    if (isHtml) {
      messageText.innerHTML = text;
    } else if (!isUser) {
      // ボットメッセージの場合はマークダウンをレンダリング
      const { renderMarkdown } = await import("markdown_renderer");
      messageText.innerHTML = renderMarkdown(text);
    } else {
      messageText.textContent = text;
    }
    
    content.appendChild(header);
    content.appendChild(messageText);
    
    messageDiv.appendChild(avatar);
    messageDiv.appendChild(content);
    
    this.chatMessages.appendChild(messageDiv);
    this.scrollToBottom();
    
    return messageDiv;
  }
  
  showTypingIndicator() {
    // ... タイピングインジケーター表示ロジック
  }
  
  removeTypingIndicator() {
    const indicator = document.getElementById('typing-indicator');
    if (indicator) {
      indicator.remove();
    }
  }
  
  updateTypingIndicator(message) {
    const indicator = document.getElementById('typing-indicator');
    if (!indicator) return;
    
    const content = indicator.querySelector('.message-content');
    if (!content) return;
    
    content.innerHTML = `<div style="color: #667eea; font-weight: bold;">${message}</div>`;
    this.scrollToBottom();
  }
  
  getTimestamp() {
    const now = new Date();
    const hours = now.getHours().toString().padStart(2, '0');
    const minutes = now.getMinutes().toString().padStart(2, '0');
    return `${hours}:${minutes}`;
  }
  
  scrollToBottom() {
    this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
  }
  
  showDataSelectionMessage(selectedData, shouldDisplayOnMap) {
    // ... データ選択メッセージ表示ロジック
  }
  
  clearChat() {
    if (confirm('チャット履歴を削除しますか？')) {
      const welcomeMessage = this.chatMessages.querySelector('.bot-message');
      this.chatMessages.innerHTML = '';
      this.chatMessages.appendChild(welcomeMessage);
      this.messageId = 0;
      this.chatHistory = [];
      return true;
    }
    return false;
  }
}
```

各ファイルで使用：

```javascript
// chatbot_map_application.js
import { ChatUI } from "chatbot/core";

const chatUI = new ChatUI({
  chatMessages: document.getElementById('chatMessages'),
  messageInput: document.getElementById('messageInput'),
  sendBtn: document.getElementById('sendBtn')
});

function initializeChatbot(viewer, loadGeoJSON) {
  // chatUIを使用して各種機能を実装
  chatUI.addMessage("ようこそ！", false);
}
```

#### 効果
- コード重複の削減（約200行の削減）
- 一貫したUI動作
- バグ修正時の影響範囲の最小化
- テスト容易性の向上

---

### 4. **AI判定処理の複数呼び出しの最適化（優先度: 低）**

#### 問題点
`ChatbotController`で判定APIを2回呼び出しています。

```ruby
# app/controllers/api/chatbot_controller.rb
map_determiner = Api::MapDisplayDeterminer.new
should_display_on_map = map_determiner.should_display_on_map?(user_query)

google_maps_determiner = Api::GoogleMapsDeterminer.new
should_use_google_maps = google_maps_determiner.should_use_google_maps?(user_query)
```

#### 推奨される改善策

1回のAPI呼び出しで2つの判定を同時に行う：

```ruby
# app/services/api/chat_intent_determiner.rb
class Api::ChatIntentDeterminer
  include ActiveModel::Model
  include ActiveModel::Attributes
  include Api::Concerns::DeepseekApiClient
  
  # 1回のAPI呼び出しで全ての判定を行う
  def determine_intent(user_query)
    return default_response if user_query.blank?
    
    system_prompt = <<~PROMPT
      ユーザーの質問内容を分析し、以下の判定を行ってください：
      1. マップ上にデータを表示する必要があるか
      2. Google Maps APIを使用する必要があるか
      
      JSON形式で返してください：
      {
        "should_display_on_map": true/false,
        "should_use_google_maps": true/false
      }
    PROMPT
    
    user_prompt = "ユーザーの質問: #{user_query}"
    
    messages = [
      { role: "system", content: system_prompt },
      { role: "user", content: user_prompt }
    ]
    
    params = {
      model: MODEL,
      messages: messages,
      response_format: { type: "json_object" }
    }
    
    response = make_request("/v1/chat/completions", params)
    
    if response && response["choices"]&.first
      ai_response = response["choices"].first["message"]["content"]
      JSON.parse(ai_response)
    else
      default_response
    end
  rescue => e
    Rails.logger.error "Intent determination error: #{e.message}"
    default_response
  end
  
  private
  
  def default_response
    { should_display_on_map: false, should_use_google_maps: false }
  end
end
```

コントローラーでの使用：

```ruby
# app/controllers/api/chatbot_controller.rb
determiner = Api::ChatIntentDeterminer.new
intent = determiner.determine_intent(user_query)

should_display_on_map = intent[:should_display_on_map]
should_use_google_maps = intent[:should_use_google_maps]
```

#### 効果
- API呼び出し数の削減（2回→1回）
- レスポンス時間の短縮
- APIコストの削減
- 判定の一貫性向上

---

### 5. **データベースクエリの最適化（優先度: 低）**

#### 問題点
`MainController`でデータ型ごとに個別のクエリを実行しています。

```ruby
# app/controllers/main_controller.rb
@point_data = @geojson_data.by_data_type("Point").visible.ordered
@line_data = @geojson_data.by_data_type("MultiLineString").visible.ordered
@tileset_data = @geojson_data.by_data_type("3DTiles").visible.ordered
@osm_data = @geojson_data.by_data_type("OSM").visible.ordered
```

#### 推奨される改善策

1回のクエリで全データを取得し、Ruby側でグループ化：

```ruby
# app/controllers/main_controller.rb
def cesium
  # 1回のクエリで全データを取得
  @all_geojson_data = @geojson_data.index_by(&:data_type)
  
  @point_data = @all_geojson_data["Point"] || []
  @line_data = @all_geojson_data["MultiLineString"] || []
  @tileset_data = @all_geojson_data["3DTiles"] || []
  @osm_data = @all_geojson_data["OSM"] || []
  
  ensure_default_filters
end
```

または、メモ化を使用：

```ruby
class MainController < ApplicationController
  private
  
  def geojson_data_by_type
    @geojson_data_by_type ||= @geojson_data.group_by(&:data_type)
  end
  
  helper_method :geojson_data_by_type
  
  def cesium
    @geojson_data_by_type = geojson_data_by_type
    
    @point_data = geojson_data_by_type["Point"] || []
    @line_data = geojson_data_by_type["MultiLineString"] || []
    @tileset_data = geojson_data_by_type["3DTiles"] || []
    @osm_data = geojson_data_by_type["OSM"] || []
    
    ensure_default_filters
  end
end
```

#### 効果
- データベースクエリ数の削減
- ページ読み込み時間の短縮
- データベース負荷の軽減

---

### 6. **フィルタ条件の重複処理の削減（優先度: 低）**

#### 問題点
`ensure_default_filters`が複数のアクションで呼ばれています。

```ruby
# app/controllers/main_controller.rb
def cesium
  # ...
  ensure_default_filters
end

def map2d
  # ...
  ensure_default_filters
end

def chatbot_map
  # ...
  ensure_default_filters
end
```

#### 推奨される改善策

`load_filter_conditions`メソッド内で統合：

```ruby
def load_filter_conditions
  @filter_conditions = FilterCondition.active.ordered
  
  # データが空の場合は自動的に読み込み
  if @filter_conditions.empty?
    @filter_conditions = FilterCondition.create_default_filters
  end
end

# ensure_default_filtersメソッドは削除可能
```

#### 効果
- コードの簡素化
- 重複処理の削減

---

## 推奨される実装順序

1. **HTTPリクエストの共通化**（優先度: 高）
   - 効果が大きい
   - 比較的簡単に実装可能
   - 影響範囲が明確

2. **console.logの整理**（優先度: 中）
   - 本番環境でのパフォーマンス改善
   - 段階的に実装可能

3. **chatbot機能の共通化**（優先度: 中）
   - コードの保守性向上
   - バグ修正時の影響範囲縮小

4. **データベースクエリの最適化**（優先度: 低）
   - パフォーマンス改善
   - 現在の負荷が許容範囲なら後回し可

5. **AI判定処理の最適化**（優先度: 低）
   - APIコスト削減
   - レスポンス時間短縮

6. **フィルタ条件の重複処理削減**（優先度: 低）
   - コードの簡素化
   - 影響は小さい

## 期待される効果まとめ

### コード品質
- 重複コード削減: 約350行
- 保守性向上: 共通化により変更影響範囲を縮小
- テスト容易性向上: 共通機能のテストが簡潔に

### パフォーマンス
- API呼び出し削減: 判定処理で50%削減
- データベースクエリ削減: 複数ページで約75%削減
- 本番環境のログ出力削減: ほぼ100%削減

### コスト
- APIコスト削減: 判定処理の統合により約50%削減
- サーバーリソース削減: クエリ最適化により軽減

### 運用
- エラーハンドリングの一貫性向上
- ログの可読性向上（構造化ログ）
- デバッグ容易性の向上

## 今後の検討事項

1. **テストコードの追加**: 共通化した機能のテスト追加
2. **パフォーマンス測定**: 最適化前後のベンチマーク取得
3. **監視とアラート**: 本番環境でのパフォーマンス監視
4. **ドキュメント整備**: 共通機能の使用方法のドキュメント化

